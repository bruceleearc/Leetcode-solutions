```

Reverse integer

```python
# Runtime 35ms beats 81.62%
# Memory 17.71mb beats 57.47%
class Solution:
    def reverse(self, x: int) -> int:
        

        if x <= 0:
            reversed = [i for i in str(abs(x))][::-1]
            if int(''.join(reversed)) in range(-2**31, 2**31):
                return(-int(''.join(reversed)))
            else:
                return(0)

        if x > 0:
            reversed = [i for i in str(abs(x))][::-1]
            if int(''.join(reversed)) in range(-2**31, 2**31):
                return(int(''.join(reversed)))
            else:
                return(0)
```

Palindrome Number

```python
# Runtime 3ms beats 88.31%
# Memory 17.76mb beats 64.42%
class Solution:
    def isPalindrome(self, number:int):

        if number < 0:
            return(False)

        elif int(number) >= 0:
            number = str(number)
            palindrome = number[::-1]

            if palindrome == number:
                return(True)
            else:
                return(False)
number = Solution()
print(Solution.isPalindrome(number, 10))

```

Integer to Roman

```python
# Runtime 3ms beats 79.98%
# Memory 17.62mb beats 91.83%
class Solution:
    def intToRoman(self, num: int) -> str:
        value_symbols = [
            (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),
            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'),
            (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')
        ]

        res = []

        for value, symbol in value_symbols:
            if num == 0:
                break
            count = num // value
            res.append(symbol * count)
            num -= count * value

        return ''.join(res)

solution = Solution()
print(solution.intToRoman(num = 3749))

```

Multiply Strings

```python
# Runtime 0ms beats 100%
# Memory 17.91mb beats 26.03%
class Solution():
    def multiply(self, num1: str, num2: str): 
        dic = {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
        }
        nl1 = []
        nl2 = []
        for i in num1:
            nl1.append(dic[i])
        for i in num2:
            nl2.append(dic[i])

        joined1 = 0 
        for i in range(len(nl1)):
            joined1 = joined1 * 10 + nl1[i]
        joined2 = 0
        for i in range(len(nl2)):
            joined2 = joined2 * 10 + nl2[i]
        return str(joined1 * joined2)
    
x = Solution()
print(x.multiply(num1 = "123", num2 = "456"))

```

Image rotation

```python
# Runtime 0 ms Beats 100%
# Memory 17.64mb Beats 91.29%
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        for i in range(len(matrix)):
            for j in range(i + 1, len(matrix[0])):  # Start j from i+1
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for row in matrix:
            row = row.reverse()
            
```

Pow(x,n)

```python
# Runtime 0ms Beats 100%
# Memory 17.63mb Beats 94.46%
class Solution:
    def myPow(self, x: float, n: int) -> float:
        return x**n
        
```

Happy Number

```python
# Runtime 3ms beats 40.23% Memory 17.83mb beats 37.9%
class Solution:
    def isHappy(self, num: int) -> bool:
        seen = set()
        while num != 1:
            if num in seen:
                return False
            else:
                seen.add(num)
                num = sum(int(digit)**2 for digit in str(num))
            
        if num == 1:
            return True
```

Power of 2, 3 and 4

```python
# 0 ms runtime: Beats 100%
# 17.68 memory: Beats 83.7%
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 1:
            return True
        if n%2 != 0 or n == 0:
            return False
        else:
            return self.isPowerOfTwo(n//2)

# 4ms beats 86.96%
# 17.8mb memory beats 72.19%
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n == 1:
            return True
        if n%3 != 0 or n == 0:
            return False
        else:
            return self.isPowerOfThree(n//3)

# 0ms beats 100%
# 17.74mb Beats 61.43% 
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 4 == 0:
            n //= 4
        if n == 1:
            return True
        else:
            return False
        
    
        

        
```

Add digits

```python
# 0ms runtime: Beats 100%
# memory: 17.81mb beats 37.04%
def adddigits(n):
    while n >= 10:
        digits = [int(d) for d in str(n)]
        n = sum(digits)
    return n
    
```

Ugly number

```python
# Runtime 0ms, Beats 100%
# Memory 17.78mb, Beats 69.98%
class Solution:
    def isUgly(self, n: int) -> bool:
            if n <= 0:
                return False
            while n != 1:
                if n % 2 == 0:
                    n //= 2
                elif n % 3 == 0:
                    n //= 3
                elif n % 5 == 0:
                    n //= 5
                else:
                    return False
            return True
	        
```

Missing number

```python
# Runtime 0ms
# Memory 18.67mb beats 72%
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        expected_sum = n * (n + 1) // 2
        actual_sum = sum(nums)
        return expected_sum - actual_sum

```

NimGame

```python
# 0ms Runtime, 17.76mb memory beats 56.89%
class Solution:
    def canWinNim(self, n: int) -> bool:
        if n % 4 == 0:
            return False
        else:
            return True
        
```

Perfect square 

```python
# Runtime 0 ms
# Memory 17.99mb beats 9%
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x = num**0.5
        if num/x == int(x):
            return True
        return False
    
        
```

Fizz Buzz

```python
# 0ms Runtime
# 18.66mb Memory Beats 25.25%
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        result = [i for i in range(1, n+1)]
        for i in result:
            if i % 3 == 0 and i % 5 == 0:
                result[i-1] = "FizzBuzz"
            elif i % 3 == 0:
                result[i-1] = "Fizz"
            elif i % 5 == 0:
                result[i-1] = "Buzz"
        return list(map(str, result))
```

Arrange coins

```python
# Runtime 527ms Beays 17.83%
# Memory 17.7mb beats 81.75%
class Solution:
    def arrangeCoins(self, n: int) -> int:
        count = 0
        row = 1
        while n >= 0:
            n -= row
            row += 1
            count += 1
        return count-1
```

Container with most water

```python
# Runtime 111ms beats 21.31%
# Memory 28.44mb beats 68.25%
class Solution:
    def maxArea(self, height: list[int]) -> int:
        l, r = 0, len(height) - 1
        res = 0
        while l < r:
            area = (r - l) * min(height[l], height[r])
            res = max(res, area)
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return res
```

Search in rotated array

```python
# Runtime 0ms Beats 100%
# Memory 17.76mb Beats 98.84%
class Solution:
    def search(self, nums: list[int], target: int) -> int:
        if target in nums:
            return nums.index(target)
        else:
            return -1
```

Valid sudoku

```python
# Runtime 3ms, Beats 81.08%
# 17.79mb Memory, Beats 69.52%
class Solution:
    def isValidSudoku(self, board: list[list[str]]) -> bool:
        # Row check
        toremove = "."
        for i in board:
            i = [j for j in i if j != toremove]
            if len(i) != len(set(i)):
                return False
        tboard = [list(row) for row in zip(*board)]
        for i in tboard:
            i = [j for j in i if j != toremove]
            if len(i) != len(set(i)):
                return False
            
        subgrids = [
                    [ 
                        [board[r + i][c + j] for j in range(3)]
                    for i in range(3)
                    ]
                    for r in range(0, 9, 3)  # row offsets: 0, 3, 6
                    for c in range(0, 9, 3)  # column offsets: 0, 3, 6
                    ]
        
        for subgrid in subgrids:
            nums = [num for row in subgrid for num in row if num != toremove]
            if len(nums) != len(set(nums)):
                    return False
        return True

```

Jumps

```python
# Runtime 3ms Beats 96.91%
# Memory: 18.61mb Beats 56.92%
class Solution:
    def jump(self, nums: list[int]) -> int:
        jumps = 0
        current_end = 0 
        farthest = 0     

        for i in range(len(nums) - 1):
            farthest = max(farthest, i + nums[i])
    
            if i == current_end:  
                jumps += 1
                current_end = farthest  

        return jumps
        
```

Group anagrams

```python
from collections import defaultdict

class Solution:
    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:
        groups = defaultdict(list)
        
        for word in strs:
            counts = [0] * 26
            for ch in word:
                counts[ord(ch) - ord('a')] += 1
            groups[tuple(counts)].append(word)
        
        return list(groups.values())

```

Max Subarray

```python
# 101 ms Rutime beats 9.4%
# Memory 31.72mb beats 90.01%
class Solution:
    def maxSubArray(self, nums: list[int]) -> int:
        current = nums[0]
        best = nums[0]
        
        for i in range(1, len(nums)):   # <-- start from 1
            current = max(nums[i], nums[i] + current)
            best = max(best, current)
        
        return best

```

Jump Game 1

```python
# 26ms Beast 59.44%
# 18.78mb Memory beats 28.36%
class Solution:
    def canJump(self, nums: list[int]) -> bool:
        max_reach = 0
        for i, jump in enumerate(nums):
            if i > max_reach:
                return False
            max_reach = max(max_reach, i + jump)
            if max_reach >= len(nums) - 1:
                return True
        return False
        
```

Merge intervals

```python
# Runtime 11ms Beats 30%
# Memory 20.96mb Beats 63.71%
class Solution:
    def merge(self, intervals: list[list[int]]) -> list[list[int]]:
        i = 0
        intervals.sort()
        ranges = [intervals[0]]

        def overlap(interval1, interval2):
            if interval2[0] <= interval1[1] and interval1[0] <= interval2[1]:
                return True
            else:
                return False
            
        while i < len(intervals):
            if overlap(ranges[-1],intervals[i]):
                ranges[-1][0] = min(ranges[-1][0],intervals[i][0])
                ranges[-1][1] = max(ranges[-1][1],intervals[i][1])
 
                
            
            else:
                ranges.append(intervals[i])
                
            i+=1

            
        
        return ranges
    
```

Insert Interval

```python
# Runtime 1ms Beats 65.75%
# 19.69mb Memory beats 60.36%
class Solution:
    def insert(self, intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:
        intervals.append(newInterval)
        intervals.sort()
        ranges = [intervals[0]]
        i = 0
        def overlap(interval1, interval2):
            if interval2[0] <= interval1[1] and interval1[0] <= interval2[1]:
                return True
            else:
                return False
            
        while i < len(intervals):
            if overlap(ranges[-1],intervals[i]):
                ranges[-1][0] = min(ranges[-1][0],intervals[i][0])
                ranges[-1][1] = max(ranges[-1][1],intervals[i][1])
 
                
            
            else:
                ranges.append(intervals[i])
                
            i+=1

        return ranges
```

Unique paths 2

```python
# 0ms Runtime beats 100%
# 18.08mb Memory beats 30%
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:
        dp = [[0] * len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]
        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0
        for i in range(1, len(obstacleGrid)):
            dp[i][0] = dp[i-1][0] if obstacleGrid[i][0] == 0 else 0

        for j in range(1, len(obstacleGrid[0])):
            dp[0][j] = dp[0][j-1] if obstacleGrid[0][j] == 0 else 0

        for i in range(1,len(obstacleGrid)):
            for j in range(1,len(obstacleGrid[0])):
                if obstacleGrid[i][j] != 1:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]

                else:
                    dp[i][j] = 0

        return dp[-1][-1]

```

Reverse Polish Notation

```python
# Runtime 2ms Beats 71.69%
# 19.04mb Memory beats 88.18%
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
            stack = []
            for token in tokens:
                if token in {"+", "-", "*", "/"}:
                    b = stack.pop()
                    a = stack.pop()
                    if token == "+":
                        stack.append(a + b)
                    elif token == "-":
                        stack.append(a - b)
                    elif token == "*":
                        stack.append(a * b)
                    else: 
                        stack.append(int(a / b))  
                else:
                    stack.append(int(token))
            return stack[0]
```

Ugly Number 2

```python
# Runtime 47ms Beats 79.14%
# Memory 17.78mb Beats 79.95%
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        ugly = [1]  # first ugly number
        i2 = i3 = i5 = 0  # indices for multiples of 2, 3, 5

        while len(ugly) < n:
            next2, next3, next5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]
            next_val = min(next2, next3, next5)
            ugly.append(next_val)

            if next_val == next2:
                i2 += 1
            if next_val == next3:
                i3 += 1
            if next_val == next5:
                i5 += 1

        return ugly[-1]

```

Count primes

```python
# Runtime 1716ms beats 33.41%
# Memory 70.12mb Beats 23.55%
class Solution:
    def countPrimes(self, n: int) -> int:
        if n <= 2:
            return 0
        else:
            primes = [True] * (n+1)
            primes[0] = primes[1] = False
            p = 2
            while p * p <= n:
                if primes[p]:
                    for i in range(p*p, n+1, p):
                        primes[i] = False
                p += 1
            res = [i for i, is_p in enumerate(primes) if is_p]
            if n in res:
                return len(res)-1
            else:
                return len(res)
```

Rectangle Area

```python
# 0ms Beats 100%
# 17.73mb Beats 86.87%
class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        area1 = abs(ax2-ax1)*abs(ay2-ay1)
        area2 = abs(bx2-bx1)*abs(by2-by1)
        overlapx1 = max(ax1,bx1)
        overlapx2 = min(ax2,bx2)
        overlapy1 = max(ay1,by1)
        overlapy2 = min(ay2,by2)
        if overlapx2 > overlapx1 and overlapy2 > overlapy1:
            overlaparea = (overlapx2-overlapx1)*(overlapy2-overlapy1)
            return area1+area2-overlaparea
        else:
            return area1 + area2
        
```

Bulb switch

```python
# Beats 100% at 0ms runtime
# 17.68mb Memory beats 76.49%

class Solution:
    def bulbSwitch(self, n: int) -> int:
        import math
        return int(math.sqrt(n))
```

Unique Paths 1

```python
# 0ms Runtime beats 100%
# 17.83mb Memory Beats 45.63%

import math
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:

        return int(math.factorial(m+n-2)/(math.factorial(m-1)*math.factorial(n-1)))
```

Excel Column Number to title

```python
# Runtime 0ms Beats 100%
# 17.98mb Memory beats 18.33%

class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        dic = {'A':1,
               'B':2,
               'C':3,
               'D':4,
               'E':5,
               'F':6,
               'G':7,
               'H':8,
               'I':9,
               'J':10,
               'K':11,
               'L':12,
               'M':13,
               'N':14,
               'O':15,
               'P':16,
               'Q':17,
               'R':18,
               'S':19,
               'T':20,
               'U':21,
               'V':22,
               'W':23,
               'X':24,
               'Y':25,
               'Z':26}
        res = ''
        while columnNumber > 0:
            for key, value in dic.items():
                if columnNumber % 26 == 0 and value == 26:
                    res = key + res
                    columnNumber -= value
                    break
                elif columnNumber % 26 == value:
                    res = key + res
                    columnNumber -= value
                    break
            columnNumber //= 26
        return res
    
```

Title to number

```python
# 0ms Beats 100%
# 17.74mb Beats 48.52%
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        dic = {'A':1,
               'B':2,
               'C':3,
               'D':4,
               'E':5,
               'F':6,
               'G':7,
               'H':8,
               'I':9,
               'J':10,
               'K':11,
               'L':12,
               'M':13,
               'N':14,
               'O':15,
               'P':16,
               'Q':17,
               'R':18,
               'S':19,
               'T':20,
               'U':21,
               'V':22,
               'W':23,
               'X':24,
               'Y':25,
               'Z':26}
        res = 0
        letters = list(columnTitle)
        for i in letters:
            res = res*26 + dic[i]
        return res
```

Letter combinations of a Phone Number

```python
class Solution:
    def letterCombinations(self, digits: str) -> list[str]:
        digit_to_char = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        for i in digits:
            if i not in digit_to_char:
                return []
        result = []
        for digit in digits:
                if not result:
                    for char in digit_to_char[digit]:
                        result.append(char)
                else:
                    temp = []
                    for char in digit_to_char[digit]:
                        for existing in result:
                            temp.append(existing + char)
                    result = temp
        return result
```

First missing positive

```python
# Runtime 35ms
# Memory 37.34mb Beats 5.04%
class Solution:
    def firstMissingPositive(self, nums: list[int]) -> int:
        nums = list(set(x for x in set(nums) if x > 0))
        nums.sort()
        for i in range(len(nums)):
            if nums[i] != i + 1:
                return i + 1
        return len(nums) + 1
    
    
```

Longest substring without repeating characters

```python
# 15ms Beats 80.22%
# 17.77mb Memory beats 82.17%
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res = ''
        max_length = 0
        for i in s:
            if i not in res:
                res += i
            else:
                index = res.index(i)
                res = res[index+1:]+i

            max_length = max(max_length, len(res))
        
        return max_length
```

Set Matrix zeroes

```python
# Runtime 3ms Beats 71.11%
# 18.27mb Memory beats 95.76%
class Solution:
    def setZeroes(self, matrix: list[list[int]]) -> None:
        zero_positions = []
        for row_idx in range(len(matrix)):
            for column_idx in range(len(matrix[0])):
                if matrix[row_idx][column_idx] == 0:
                    zero_positions.append([row_idx,column_idx])

        for i in zero_positions:
            for j in range(len(matrix[0])):
                matrix[i[0]][j] = 0
            for k in range(len(matrix)):
                matrix[k][i[1]] = 0
                    
        
   

```

Longest consecutive sequence

```python
# Runtime 15.96%
# Memory 34.22 mb Beats 51.13%

class Solution:
    def longestConsecutive(self, nums: list[int]) -> int:
        res = 0
        temp = []
        nums = list(set(nums))
        nums.sort()
        i = 0
        while i < len(nums):
            if i == 0 or nums[i] - nums[i-1] == 1:
                temp.append(nums[i])
                res = max(res, len(temp))

            else:
                temp = [nums[i]]
                res = max(res, len(temp))
            i += 1
        
        return res
```

Median of Two sorted Arrays

```python
# Runtime 0ms Beats 100%
# 17.7mb Beatsa\ 99.95%
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        for i in nums2:
            nums1.append(i)
        nums1.sort()
        i = len(nums1)
        if i%2 == 0:
            return((nums1[int(i/2)]+nums1[int(i/2-1)])/2)
        elif i % 2 == 1 :
            return(nums1[int(i/2)])

```

Zigzag conversion

```python
# Runtime 15ms Beats 36.52%
# Memory 18mb Beats 49.54$

class Solution:
    def convert(self, s: str, numRows: int) -> str:
        reslist = [[] for _ in range(numRows)]
        if numRows == 1:
            return s
        else:
            n = 0
            direction = 1
            for i in range(len(s)):
                reslist[n].append(s[i])
                n += direction
                
                if n == numRows-1:
                    direction = -1
                elif n == 0:
                    direction = 1
                
            res = ''
            for i in reslist:
                for j in i:
                    res += j

            return res
```
