Add two numbers

```python
# Definition for singly-linked list.
# class ListNode:
#     def __init__(self, val=0, next=None):
#         self.val = val
#         self.next = next
class Solution:
    def addTwoNumbers(self, l1: ListNode, l2: ListNode) -> ListNode:
        dummyHead = ListNode(0)
        tail = dummyHead
        carry = 0

        while l1 is not None or l2 is not None or carry != 0:
            digit1 = l1.val if l1 is not None else 0
            digit2 = l2.val if l2 is not None else 0

            sum = digit1 + digit2 + carry
            digit = sum % 10
            carry = sum // 10

            newNode = ListNode(digit)
            tail.next = newNode
            tail = tail.next

            l1 = l1.next if l1 is not None else None
            l2 = l2.next if l2 is not None else None

        result = dummyHead.next
        dummyHead.next = None
        return result

```

Reverse integer

```python
# Runtime 35ms beats 81.62%
# Memory 17.71mb beats 57.47%
class Solution:
    def reverse(self, x: int) -> int:
        

        if x <= 0:
            reversed = [i for i in str(abs(x))][::-1]
            if int(''.join(reversed)) in range(-2**31, 2**31):
                return(-int(''.join(reversed)))
            else:
                return(0)

        if x > 0:
            reversed = [i for i in str(abs(x))][::-1]
            if int(''.join(reversed)) in range(-2**31, 2**31):
                return(int(''.join(reversed)))
            else:
                return(0)
```

Palindrome Number

```python
# Runtime 3ms beats 88.31%
# Memory 17.76mb beats 64.42%
class Solution:
    def isPalindrome(self, number:int):

        if number < 0:
            return(False)

        elif int(number) >= 0:
            number = str(number)
            palindrome = number[::-1]

            if palindrome == number:
                return(True)
            else:
                return(False)
number = Solution()
print(Solution.isPalindrome(number, 10))

```

Integer to Roman

```python
# Runtime 3ms beats 79.98%
# Memory 17.62mb beats 91.83%
class Solution:
    def intToRoman(self, num: int) -> str:
        value_symbols = [
            (1000, 'M'), (900, 'CM'), (500, 'D'), (400, 'CD'),
            (100, 'C'), (90, 'XC'), (50, 'L'), (40, 'XL'), (10, 'X'),
            (9, 'IX'), (5, 'V'), (4, 'IV'), (1, 'I')
        ]

        res = []

        for value, symbol in value_symbols:
            if num == 0:
                break
            count = num // value
            res.append(symbol * count)
            num -= count * value

        return ''.join(res)

solution = Solution()
print(solution.intToRoman(num = 3749))

```

Multiply Strings

```python
# Runtime 0ms beats 100%
# Memory 17.91mb beats 26.03%
class Solution():
    def multiply(self, num1: str, num2: str): 
        dic = {
            "0": 0,
            "1": 1,
            "2": 2,
            "3": 3,
            "4": 4,
            "5": 5,
            "6": 6,
            "7": 7,
            "8": 8,
            "9": 9,
        }
        nl1 = []
        nl2 = []
        for i in num1:
            nl1.append(dic[i])
        for i in num2:
            nl2.append(dic[i])

        joined1 = 0 
        for i in range(len(nl1)):
            joined1 = joined1 * 10 + nl1[i]
        joined2 = 0
        for i in range(len(nl2)):
            joined2 = joined2 * 10 + nl2[i]
        return str(joined1 * joined2)
    
x = Solution()
print(x.multiply(num1 = "123", num2 = "456"))

```

Image rotation

```python
# Runtime 0 ms Beats 100%
# Memory 17.64mb Beats 91.29%
class Solution:
    def rotate(self, matrix: List[List[int]]) -> None:
        for i in range(len(matrix)):
            for j in range(i + 1, len(matrix[0])):  # Start j from i+1
                matrix[i][j], matrix[j][i] = matrix[j][i], matrix[i][j]
        for row in matrix:
            row = row.reverse()
            
```

Pow(x,n)

```python
# Runtime 0ms Beats 100%
# Memory 17.63mb Beats 94.46%
class Solution:
    def myPow(self, x: float, n: int) -> float:
        return x**n
        
```

Happy Number

```python
# Runtime 3ms beats 40.23% Memory 17.83mb beats 37.9%
class Solution:
    def isHappy(self, num: int) -> bool:
        seen = set()
        while num != 1:
            if num in seen:
                return False
            else:
                seen.add(num)
                num = sum(int(digit)**2 for digit in str(num))
            
        if num == 1:
            return True
```

Power of 2, 3 and 4

```python
# 0 ms runtime: Beats 100%
# 17.68 memory: Beats 83.7%
class Solution:
    def isPowerOfTwo(self, n: int) -> bool:
        if n == 1:
            return True
        if n%2 != 0 or n == 0:
            return False
        else:
            return self.isPowerOfTwo(n//2)

# 4ms beats 86.96%
# 17.8mb memory beats 72.19%
class Solution:
    def isPowerOfThree(self, n: int) -> bool:
        if n == 1:
            return True
        if n%3 != 0 or n == 0:
            return False
        else:
            return self.isPowerOfThree(n//3)

# 0ms beats 100%
# 17.74mb Beats 61.43% 
class Solution:
    def isPowerOfFour(self, n: int) -> bool:
        if n <= 0:
            return False
        while n % 4 == 0:
            n //= 4
        if n == 1:
            return True
        else:
            return False
        
    
        

        
```

Add digits

```python
# 0ms runtime: Beats 100%
# memory: 17.81mb beats 37.04%
def adddigits(n):
    while n >= 10:
        digits = [int(d) for d in str(n)]
        n = sum(digits)
    return n
    
```

Ugly number

```python
# Runtime 0ms, Beats 100%
# Memory 17.78mb, Beats 69.98%
class Solution:
    def isUgly(self, n: int) -> bool:
            if n <= 0:
                return False
            while n != 1:
                if n % 2 == 0:
                    n //= 2
                elif n % 3 == 0:
                    n //= 3
                elif n % 5 == 0:
                    n //= 5
                else:
                    return False
            return True
	        
```

Missing number

```python
# Runtime 0ms
# Memory 18.67mb beats 72%
class Solution:
    def missingNumber(self, nums: List[int]) -> int:
        n = len(nums)
        expected_sum = n * (n + 1) // 2
        actual_sum = sum(nums)
        return expected_sum - actual_sum

```

NimGame

```python
# 0ms Runtime, 17.76mb memory beats 56.89%
class Solution:
    def canWinNim(self, n: int) -> bool:
        if n % 4 == 0:
            return False
        else:
            return True
        
```

Perfect square 

```python
# Runtime 0 ms
# Memory 17.99mb beats 9%
class Solution:
    def isPerfectSquare(self, num: int) -> bool:
        x = num**0.5
        if num/x == int(x):
            return True
        return False
    
        
```

Fizz Buzz

```python
# 0ms Runtime
# 18.66mb Memory Beats 25.25%
class Solution:
    def fizzBuzz(self, n: int) -> List[str]:
        result = [i for i in range(1, n+1)]
        for i in result:
            if i % 3 == 0 and i % 5 == 0:
                result[i-1] = "FizzBuzz"
            elif i % 3 == 0:
                result[i-1] = "Fizz"
            elif i % 5 == 0:
                result[i-1] = "Buzz"
        return list(map(str, result))
```

Arrange coins

```python
# Runtime 527ms Beays 17.83%
# Memory 17.7mb beats 81.75%
class Solution:
    def arrangeCoins(self, n: int) -> int:
        count = 0
        row = 1
        while n >= 0:
            n -= row
            row += 1
            count += 1
        return count-1
```

Container with most water

```python
# Runtime 111ms beats 21.31%
# Memory 28.44mb beats 68.25%
class Solution:
    def maxArea(self, height: list[int]) -> int:
        l, r = 0, len(height) - 1
        res = 0
        while l < r:
            area = (r - l) * min(height[l], height[r])
            res = max(res, area)
            if height[l] < height[r]:
                l += 1
            else:
                r -= 1
        return res
```

Search in rotated array

```python
# Runtime 0ms Beats 100%
# Memory 17.76mb Beats 98.84%
class Solution:
    def search(self, nums: list[int], target: int) -> int:
        if target in nums:
            return nums.index(target)
        else:
            return -1
```

Valid sudoku

```python
# Runtime 3ms, Beats 81.08%
# 17.79mb Memory, Beats 69.52%
class Solution:
    def isValidSudoku(self, board: list[list[str]]) -> bool:
        # Row check
        toremove = "."
        for i in board:
            i = [j for j in i if j != toremove]
            if len(i) != len(set(i)):
                return False
        tboard = [list(row) for row in zip(*board)]
        for i in tboard:
            i = [j for j in i if j != toremove]
            if len(i) != len(set(i)):
                return False
            
        subgrids = [
                    [ 
                        [board[r + i][c + j] for j in range(3)]
                    for i in range(3)
                    ]
                    for r in range(0, 9, 3)  # row offsets: 0, 3, 6
                    for c in range(0, 9, 3)  # column offsets: 0, 3, 6
                    ]
        
        for subgrid in subgrids:
            nums = [num for row in subgrid for num in row if num != toremove]
            if len(nums) != len(set(nums)):
                    return False
        return True

```

Jumps

```python
# Runtime 3ms Beats 96.91%
# Memory: 18.61mb Beats 56.92%
class Solution:
    def jump(self, nums: list[int]) -> int:
        jumps = 0
        current_end = 0 
        farthest = 0     

        for i in range(len(nums) - 1):
            farthest = max(farthest, i + nums[i])
    
            if i == current_end:  
                jumps += 1
                current_end = farthest  

        return jumps
        
```

Group anagrams

```python
from collections import defaultdict

class Solution:
    def groupAnagrams(self, strs: list[str]) -> list[list[str]]:
        groups = defaultdict(list)
        
        for word in strs:
            counts = [0] * 26
            for ch in word:
                counts[ord(ch) - ord('a')] += 1
            groups[tuple(counts)].append(word)
        
        return list(groups.values())

```

Max Subarray

```python
# 101 ms Rutime beats 9.4%
# Memory 31.72mb beats 90.01%
class Solution:
    def maxSubArray(self, nums: list[int]) -> int:
        current = nums[0]
        best = nums[0]
        
        for i in range(1, len(nums)):   # <-- start from 1
            current = max(nums[i], nums[i] + current)
            best = max(best, current)
        
        return best

```

Jump Game 1

```python
# 26ms Beast 59.44%
# 18.78mb Memory beats 28.36%
class Solution:
    def canJump(self, nums: list[int]) -> bool:
        max_reach = 0
        for i, jump in enumerate(nums):
            if i > max_reach:
                return False
            max_reach = max(max_reach, i + jump)
            if max_reach >= len(nums) - 1:
                return True
        return False
        
```

Merge intervals

```python
# Runtime 11ms Beats 30%
# Memory 20.96mb Beats 63.71%
class Solution:
    def merge(self, intervals: list[list[int]]) -> list[list[int]]:
        i = 0
        intervals.sort()
        ranges = [intervals[0]]

        def overlap(interval1, interval2):
            if interval2[0] <= interval1[1] and interval1[0] <= interval2[1]:
                return True
            else:
                return False
            
        while i < len(intervals):
            if overlap(ranges[-1],intervals[i]):
                ranges[-1][0] = min(ranges[-1][0],intervals[i][0])
                ranges[-1][1] = max(ranges[-1][1],intervals[i][1])
 
                
            
            else:
                ranges.append(intervals[i])
                
            i+=1

            
        
        return ranges
    
```

Insert Interval

```python
# Runtime 1ms Beats 65.75%
# 19.69mb Memory beats 60.36%
class Solution:
    def insert(self, intervals: list[list[int]], newInterval: list[int]) -> list[list[int]]:
        intervals.append(newInterval)
        intervals.sort()
        ranges = [intervals[0]]
        i = 0
        def overlap(interval1, interval2):
            if interval2[0] <= interval1[1] and interval1[0] <= interval2[1]:
                return True
            else:
                return False
            
        while i < len(intervals):
            if overlap(ranges[-1],intervals[i]):
                ranges[-1][0] = min(ranges[-1][0],intervals[i][0])
                ranges[-1][1] = max(ranges[-1][1],intervals[i][1])
 
                
            
            else:
                ranges.append(intervals[i])
                
            i+=1

        return ranges
```

Unique paths 2

```python
# 0ms Runtime beats 100%
# 18.08mb Memory beats 30%
class Solution:
    def uniquePathsWithObstacles(self, obstacleGrid: list[list[int]]) -> int:
        dp = [[0] * len(obstacleGrid[0]) for _ in range(len(obstacleGrid))]
        dp[0][0] = 1 if obstacleGrid[0][0] == 0 else 0
        for i in range(1, len(obstacleGrid)):
            dp[i][0] = dp[i-1][0] if obstacleGrid[i][0] == 0 else 0

        for j in range(1, len(obstacleGrid[0])):
            dp[0][j] = dp[0][j-1] if obstacleGrid[0][j] == 0 else 0

        for i in range(1,len(obstacleGrid)):
            for j in range(1,len(obstacleGrid[0])):
                if obstacleGrid[i][j] != 1:
                    dp[i][j] = dp[i-1][j] + dp[i][j-1]

                else:
                    dp[i][j] = 0

        return dp[-1][-1]

```

Reverse Polish Notation

```python
# Runtime 2ms Beats 71.69%
# 19.04mb Memory beats 88.18%
class Solution:
    def evalRPN(self, tokens: List[str]) -> int:
            stack = []
            for token in tokens:
                if token in {"+", "-", "*", "/"}:
                    b = stack.pop()
                    a = stack.pop()
                    if token == "+":
                        stack.append(a + b)
                    elif token == "-":
                        stack.append(a - b)
                    elif token == "*":
                        stack.append(a * b)
                    else: 
                        stack.append(int(a / b))  
                else:
                    stack.append(int(token))
            return stack[0]
```

Ugly Number 2

```python
# Runtime 47ms Beats 79.14%
# Memory 17.78mb Beats 79.95%
class Solution:
    def nthUglyNumber(self, n: int) -> int:
        ugly = [1]  # first ugly number
        i2 = i3 = i5 = 0  # indices for multiples of 2, 3, 5

        while len(ugly) < n:
            next2, next3, next5 = 2 * ugly[i2], 3 * ugly[i3], 5 * ugly[i5]
            next_val = min(next2, next3, next5)
            ugly.append(next_val)

            if next_val == next2:
                i2 += 1
            if next_val == next3:
                i3 += 1
            if next_val == next5:
                i5 += 1

        return ugly[-1]

```

Count primes

```python
# Runtime 1716ms beats 33.41%
# Memory 70.12mb Beats 23.55%
class Solution:
    def countPrimes(self, n: int) -> int:
        if n <= 2:
            return 0
        else:
            primes = [True] * (n+1)
            primes[0] = primes[1] = False
            p = 2
            while p * p <= n:
                if primes[p]:
                    for i in range(p*p, n+1, p):
                        primes[i] = False
                p += 1
            res = [i for i, is_p in enumerate(primes) if is_p]
            if n in res:
                return len(res)-1
            else:
                return len(res)
```

Rectangle Area

```python
# 0ms Beats 100%
# 17.73mb Beats 86.87%
class Solution:
    def computeArea(self, ax1: int, ay1: int, ax2: int, ay2: int, bx1: int, by1: int, bx2: int, by2: int) -> int:
        area1 = abs(ax2-ax1)*abs(ay2-ay1)
        area2 = abs(bx2-bx1)*abs(by2-by1)
        overlapx1 = max(ax1,bx1)
        overlapx2 = min(ax2,bx2)
        overlapy1 = max(ay1,by1)
        overlapy2 = min(ay2,by2)
        if overlapx2 > overlapx1 and overlapy2 > overlapy1:
            overlaparea = (overlapx2-overlapx1)*(overlapy2-overlapy1)
            return area1+area2-overlaparea
        else:
            return area1 + area2
        
```

Bulb switch

```python
# Beats 100% at 0ms runtime
# 17.68mb Memory beats 76.49%

class Solution:
    def bulbSwitch(self, n: int) -> int:
        import math
        return int(math.sqrt(n))
```

Unique Paths 1

```python
# 0ms Runtime beats 100%
# 17.83mb Memory Beats 45.63%

import math
class Solution:
    def uniquePaths(self, m: int, n: int) -> int:

        return int(math.factorial(m+n-2)/(math.factorial(m-1)*math.factorial(n-1)))
```

Excel Column Number to title

```python
# Runtime 0ms Beats 100%
# 17.98mb Memory beats 18.33%

class Solution:
    def convertToTitle(self, columnNumber: int) -> str:
        dic = {'A':1,
               'B':2,
               'C':3,
               'D':4,
               'E':5,
               'F':6,
               'G':7,
               'H':8,
               'I':9,
               'J':10,
               'K':11,
               'L':12,
               'M':13,
               'N':14,
               'O':15,
               'P':16,
               'Q':17,
               'R':18,
               'S':19,
               'T':20,
               'U':21,
               'V':22,
               'W':23,
               'X':24,
               'Y':25,
               'Z':26}
        res = ''
        while columnNumber > 0:
            for key, value in dic.items():
                if columnNumber % 26 == 0 and value == 26:
                    res = key + res
                    columnNumber -= value
                    break
                elif columnNumber % 26 == value:
                    res = key + res
                    columnNumber -= value
                    break
            columnNumber //= 26
        return res
    
```

Title to number

```python
# 0ms Beats 100%
# 17.74mb Beats 48.52%
class Solution:
    def titleToNumber(self, columnTitle: str) -> int:
        dic = {'A':1,
               'B':2,
               'C':3,
               'D':4,
               'E':5,
               'F':6,
               'G':7,
               'H':8,
               'I':9,
               'J':10,
               'K':11,
               'L':12,
               'M':13,
               'N':14,
               'O':15,
               'P':16,
               'Q':17,
               'R':18,
               'S':19,
               'T':20,
               'U':21,
               'V':22,
               'W':23,
               'X':24,
               'Y':25,
               'Z':26}
        res = 0
        letters = list(columnTitle)
        for i in letters:
            res = res*26 + dic[i]
        return res
```

Letter combinations of a Phone Number

```python
class Solution:
    def letterCombinations(self, digits: str) -> list[str]:
        digit_to_char = {
            '2': 'abc',
            '3': 'def',
            '4': 'ghi',
            '5': 'jkl',
            '6': 'mno',
            '7': 'pqrs',
            '8': 'tuv',
            '9': 'wxyz'
        }
        for i in digits:
            if i not in digit_to_char:
                return []
        result = []
        for digit in digits:
                if not result:
                    for char in digit_to_char[digit]:
                        result.append(char)
                else:
                    temp = []
                    for char in digit_to_char[digit]:
                        for existing in result:
                            temp.append(existing + char)
                    result = temp
        return result
```

First missing positive

```python
# Runtime 35ms
# Memory 37.34mb Beats 5.04%
class Solution:
    def firstMissingPositive(self, nums: list[int]) -> int:
        nums = list(set(x for x in set(nums) if x > 0))
        nums.sort()
        for i in range(len(nums)):
            if nums[i] != i + 1:
                return i + 1
        return len(nums) + 1
    
    
```

Longest substring without repeating characters

```python
# 15ms Beats 80.22%
# 17.77mb Memory beats 82.17%
class Solution:
    def lengthOfLongestSubstring(self, s: str) -> int:
        res = ''
        max_length = 0
        for i in s:
            if i not in res:
                res += i
            else:
                index = res.index(i)
                res = res[index+1:]+i

            max_length = max(max_length, len(res))
        
        return max_length
```

Set Matrix zeroes

```python
# Runtime 3ms Beats 71.11%
# 18.27mb Memory beats 95.76%
class Solution:
    def setZeroes(self, matrix: list[list[int]]) -> None:
        zero_positions = []
        for row_idx in range(len(matrix)):
            for column_idx in range(len(matrix[0])):
                if matrix[row_idx][column_idx] == 0:
                    zero_positions.append([row_idx,column_idx])

        for i in zero_positions:
            for j in range(len(matrix[0])):
                matrix[i[0]][j] = 0
            for k in range(len(matrix)):
                matrix[k][i[1]] = 0
                    
        
   

```

Longest consecutive sequence

```python
# Runtime 15.96%
# Memory 34.22 mb Beats 51.13%

class Solution:
    def longestConsecutive(self, nums: list[int]) -> int:
        res = 0
        temp = []
        nums = list(set(nums))
        nums.sort()
        i = 0
        while i < len(nums):
            if i == 0 or nums[i] - nums[i-1] == 1:
                temp.append(nums[i])
                res = max(res, len(temp))

            else:
                temp = [nums[i]]
                res = max(res, len(temp))
            i += 1
        
        return res
```

Median of Two sorted Arrays

```python
# Runtime 0ms Beats 100%
# 17.7mb Beatsa\ 99.95%
class Solution:
    def findMedianSortedArrays(self, nums1: List[int], nums2: List[int]) -> float:
        for i in nums2:
            nums1.append(i)
        nums1.sort()
        i = len(nums1)
        if i%2 == 0:
            return((nums1[int(i/2)]+nums1[int(i/2-1)])/2)
        elif i % 2 == 1 :
            return(nums1[int(i/2)])

```

Zigzag conversion

```python
# Runtime 15ms Beats 36.52%
# Memory 18mb Beats 49.54$

class Solution:
    def convert(self, s: str, numRows: int) -> str:
        reslist = [[] for _ in range(numRows)]
        if numRows == 1:
            return s
        else:
            n = 0
            direction = 1
            for i in range(len(s)):
                reslist[n].append(s[i])
                n += direction
                
                if n == numRows-1:
                    direction = -1
                elif n == 0:
                    direction = 1
                
            res = ''
            for i in reslist:
                for j in i:
                    res += j

            return res
```

Pascalâ€™s triangle 2

```python
# 3ms Beats 9.82%
# 18.09mb Beats 11.58%
class Solution:
    def getRow(self, rowIndex: int) -> list[int]:
        def factorial(n):
            if n == 0:
                return 1
            if n == 1:
                return 1
            else:
                return n*factorial(n-1)

        def combs(n,r):
            return factorial(n)/(factorial(n-r)*factorial(r))

        
        row = []
        for i in range(rowIndex+1):
            row.append(combs(rowIndex,i))
    
        row = [int(i) for i in row]

        return row
```

Is subsequence

```python
# 0ms Runtime Beats 100%
# 17.8mb Memory beats 42%
class Solution:
    def isSubsequence(self, s: str, t: str) -> bool:
        for i in s:
            if i not in t:
                return False
        if s == "":
            return True
            
        i = 0
        j = 0
        while j < len(s) and i < len(t):
            if t[i] == s[j]:
                i += 1
                j += 1
            else:
                i += 1

        if j != len(s):
            return False
        else:
            return True
```

Fibonacci

```python
# Runtime 387ms Beats 5.9%
# 17.87 mb Beats 23.65%
class Solution:
    def fib(self, n: int) -> int:
        if n == 0:
            return 0 
        if n == 1:
            return 1
        else:
            return self.fib(n-1)+self.fib(n-2)
```

Divisor Game

```python
# 0 ms runtime, beats 100%
# 17.72mb Memory, beast 63.32%
class Solution:
    def divisorGame(self, n: int) -> bool:
        if n % 2 == 0:
            return True
        else:
            return False
```

Tribonacci Numbere

```python
# 0ms runtime Beats 100%
# 17.66 mb Memory beats 78.49%
class Solution:
    def __init__(self):
        self.vals = { 0:0, 1:1, 2:1}

    def tribonacci(self, n: int) -> int:
        if n == 0:
            return 0
        if n == 1:
            return 1
        if n == 2:
            return 1
        else:
            if n not in self.vals:
             self.vals[n] = self.tribonacci(n-3)+self.tribonacci(n-2)+self.tribonacci(n-1)

            return self.vals[n]
        
```

Number of distinct averages

```python
# Beats 100% runtime, 66.13% memory
class Solution:
    def distinctAverages(self, nums: list[int]) -> int:
        distinct = set()
        while nums != []:
            average = (min(nums)+max(nums))/2
            distinct.add(average)
            nums.remove(min(nums))
            nums.remove(max(nums))
        
        return len(distinct)
```

Minimum moves for seat

```python
# Runtime 27ms Beats 6%, Memory 17.74mb beats 74.84% 
class Solution:
    def minMovesToSeat(self, seats: list[int], students: list[int]) -> int:
        moves = 0
        while seats and students != []:
            moves += abs(min(seats)-min(students))
            seats.remove(min(seats))
            students.remove(min(students))

        return moves
```

Reorder Log Files 

```python
class Solution:
    def reorderLogFiles(self, logs: list[str]) -> list[str]:
        def ident_remover(x):
            index = x.find(' ')
            content = x[index+1:]
            ident = x[:index]
            return (content,ident)
        logs_hold = []
        lets = []
        digs = []
        for i in logs:
            s = ident_remover(i)[0]
            if s[0].isdigit():
                digs.append(i)
            else:
                lets.append(i)
            logs_hold.append(i)

        lets.sort(key = ident_remover)

        for i in digs:
            lets.append(i)

        return lets
```

Lexicographical numbers

```python
# 9ms Beats 79.08% # 24.19mb beats 23.2%
class Solution:
    def lexicalOrder(self, n: int) -> list[int]:
        x = [i for i in range(1,n+1)]
        x.sort(key = str)

        return x
    
```

Delete characters to make a fancy string

```python
# 199ms Beats 87.53% 19.61mb Memory beats 50.35%

class Solution:
    def makeFancyString(self, s: str) -> str:
        current = s[0]
        count = 0
        result = ''
        for char in s:
            if current == char:
                count += 1
                
            else:
                count = 1
                current = char
            
            if count <= 2: 
                result += char
        return result
```

Find subsequence of length K with the largest sum

```python
# 11ms 13.31% beat in runtime 17.87mb memory Beats 94.74%
class Solution:
    def maxSubsequence(self, nums: list[int], k: int) -> list[int]:
        dummy = sorted(nums)
        for i in dummy[:len(nums)-k]:
            nums.remove(i)

        return nums
    
```

Sort vowels into a string

```python
# Runtime 111ms 30.25% Memory 21.15mb 25.15% 
class Solution:
    def sortVowels(self, s: str) -> str:
        vowels = ['A','E','I','O','U','a','e','i','o','u']
        reorder = []
        for idx,char in enumerate(s):
            if char in vowels:
                reorder.append(char)

        reorder.sort(key = ord)
        slist = list(s)
        vowel_idx = 0
        for i in range(len(slist)):
            if slist[i] in vowels:
                slist[i] = reorder[vowel_idx]
                vowel_idx += 1

            
        
        return ''.join(slist)
```

### Palindrome checker

```python
# 279ms beats 62.2% # 19.08mb Beats 16.38%
class Solution:
    def longestPalindrome(self, s: str) -> str:
        if len(s) <2:
            return s
        def oddexpand(word,i):
            left = i
            right = i
            while left >= 0 and right <= len(word)-1 and word[left] == word[right]:
                 left -= 1
                 right += 1

                        

                
            return word[left+1:right]
        
        def evenexpand(word,i):
            left = i
            right = i+1
            while left >= 0 and right <= len(word)-1 and word[left] == word[right]:
                left -= 1
                right += 1

            return word[left+1:right]

        palindromes = []
        for i in range(len(s)):
            palindromes.append(evenexpand(s,i))
            palindromes.append(oddexpand(s,i))

        return max(palindromes, key = len)
```

Generate Parentheses

```python
# 0ms Beats 100% 18.01mb memory beats 44.45%
class Solution:
    def generateParenthesis(self, n: int) -> list[str]:
        res = []
        def create(left,right,parentheses):
            if right == left == 0:
                res.append(parentheses)
                return 
            if left > 0 :
                create(left-1, right, parentheses = parentheses + '(')
            if right > left:
                create(left, right-1, parentheses = parentheses + ')')
        
        create(n,n,"")

        return res
```

Minimum deletions required to make string balanced

```python
# 223ms 65.43% beat, 18.03mb 82.72% beat 
class Solution:
    def minimumDeletions(self, s: str) -> int:
        bs = 0
        deletions = 0
        for i in s:
            if i == 'b':
                bs += 1

            else:
                if bs > 0:
                    deletions = min(deletions+1, bs)
                    

        return deletions
```

Getting longest non-consecutive subsequence

```python
# 0ms Beats 100% # 18.01mb Beats 8%
class Solution:
    def getLongestSubsequence(self, words: list[str], groups: list[int]) -> list[str]:
        dummy = words.copy()
        comparer = 0
        while comparer < len(groups)-1:
            if groups[comparer] == groups[comparer+1]:
                dummy.pop(comparer+1)
                groups.pop(comparer+1)
            else:
                comparer += 1

        return dummy

```

Max profit 2

```python
#Runtime 0ms Beats 100% Memory 17.91mb beats 99.95%
class Solution:
    def maxProfit(self, prices: list[int]) -> int:
        profit = 0
        for i in range(len(prices)-1):
            # buy it or no?
            # look forward by a day
            if prices[i+1] > prices[i]:
                profit += prices[i+1] - prices[i]
            
        return profit

```

House robber

```python
# 0ms Beats 100% 17.37mb Memory beats 94.86%
class Solution:
    def rob(self, nums: list[int]) -> int:
        if len(nums) == 0:
            return 0

        if len(nums) == 1:
            return nums[0]
        else:
            n = len(nums)
            dp = [0]*n
            dp[0] = nums[0]
            dp[1] = max(dp[0],nums[1])
            for i in range(2,len(nums)):
                dp[i] = max(dp[i-1],dp[i-2]+nums[i])

        return dp[n-1]
```

House Robber 2

```python

class Solution:
    def rob(self, nums: list[int]) -> int:
        
        n = len(nums)
        nums1 = nums[:-1]
        nums2 = nums[1:]

        if len(nums) == 0:
            return 0 
        
        if len(nums) == 1:
            return nums[0]

        if len(nums2) and len(nums1) == 1:
            return max(nums2[0], nums1[0])
        
        else:
            dp1 = [0]*(n-1)
            dp2 = [0]*(n-1)        
                
            dp1[0] = nums1[0]
            dp1[1] = max(nums1[1],dp1[0])
            for i in range(2, len(dp1)):
                dp1[i] = max(dp1[i-1],dp1[i-2]+nums1[i])

            dp2[0] = nums2[0]
            dp2[1] = max(dp2[0],nums2[1])
            for i in range(2, len(dp2)):
                dp2[i] = max(dp2[i-1], dp2[i-2]+nums2[i])

        return max(dp1[n-2],dp2[n-2])
            

    

        
```

Coin change

```python
# 733ms Beats 70.59% 17.57mb Memory beats 98.24%
class Solution:
    def coinChange(self, coins: list[int], amount: int) -> int:
        dp = [float('inf')]*(amount+1)
        dp[0] = 0
        for i in range(amount+1):
            for j in coins:
                if j <= i:
                    dp[i] = min(dp[i-j]+1, dp[i])

        if dp[amount] == float('inf'):
            return -1
        
        return dp[amount]
    
```

Largest divisible subset

```python
# 191ms Beats 41.3% 17.67mb Beats 88.61%
class Solution:
    def largestDivisibleSubset(self, nums: list[int]) -> list[int]:
        nums.sort()
        dp = [[i] for i in nums]
        for i in range(1,len(nums)):
            for j in range(i):
                if nums[i] % nums[j] == 0:
                    dummy = dp[j] + [nums[i]]
                    if len(dummy) > len(dp[i]):
                        dp[i] = dummy

        return max(dp,key = len)
    
```

Decode ways

```python
# 1ms Beats 39.46% 17.26 Memory beats 94.46%
class Solution:
    def numDecodings(self, s: str) -> int:
        n = len(s)
        if s[0] == '0':
            return 0
        else:
            dp = [0]*(n+1)
            dp[0] = 1
            dp[1] = 1
            for i in range(2,n+1):
                if s[i-1] != '0':
                    dp[i] = dp[i-1]

                if s[i-2] == '1' or (s[i-2] == '2' and s[i-1] <= '6'):
                    dp[i] += dp[i-2]

            return dp[n]
```

Interweaving strings

```python
# 37ms Beats 89.37% 17.45 mb Beats 92.55%
class Solution:
    def isInterleave(self, s1: str, s2: str, s3: str) -> bool:
        m = len(s1)
        n = len(s2)
        if m+n != len(s3):
            return False
        
        dp = [[False] * (n + 1) for _ in range(m + 1)]

        dp[0][0] = True
        for i in range(1,m+1):
             dp[i][0] = dp[i-1][0] and s1[i-1] == s3[i-1]
        
        
        for j in range(1,n+1):
                dp[0][j] = dp[0][j-1] and s2[j-1] == s3[j-1]

        for i in range(1, m + 1):
            for j in range(1, n + 1):
                if dp[i-1][j] == True:
                    if s1[i-1] == s3[i+j-1]:
                        dp[i][j] = True

                if dp[i][j-1] == True: 
                    if s2[j-1] == s3[i+j-1]:
                        dp[i][j] = True

        return dp[m][n]
    
```

Perfect squares (Leetcode 279)

```python
# 2683ms Runtime beats 46.91%, 17.25mb Memory beats 97.47%
class Solution:
    def numSquares(self, n: int) -> int:
        dp = [float('inf')]*(n+1)
        dp[0] = 0
        for i in range(1, n+1):
            for j in range(0,int(i**0.5)+1):
                dp[i] = min(dp[i],1+dp[i-j**2])

        return dp[n]
```

Longest Increasing subsequence (Leetcode 300)

```python
# 1831ms Runtime beats 21.81% 17.36 Memory beats 97.41%
class Solution:
    def lengthOfLIS(self, nums: list[int]) -> int:
        dp = [1] * len(nums)
        for i in range(1, len(nums)):
            for j in range(i):
                if nums[j] < nums[i]:
                    dp[i] = max(dp[i], dp[j]+1)

        return max(dp)
```

Rotate Function (Leetcode 396)

```python
# Runtime 120ms Beats 93.79% Memory 29.43mb Beats 10.4%
class Solution:
    def maxRotateFunction(self, nums: list[int]) -> int:
        
        s = sum(nums)
        current = sum([i * nums[i] for i in range(len(nums))])
        maximum = current
        for i in range(1, len(nums)):
            current = current + s - len(nums)*nums[-i]
            if current > maximum:
                maximum = current

        return maximum
    
```
